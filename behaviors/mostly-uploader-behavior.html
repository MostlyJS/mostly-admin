<script>
  var Mostly = Mostly || {};

  (function () {

    /**
     * Initializes a new default upload provider.
     *
     * @param {Object} connection an instance of nuxeo-connection to be used
     * @param {String} accept a string holding a comma separated list of accepted file types or mime types
     * @param {Boolean} batchAppend a boolean whether files should be appended to the current batch or not
     **/
    function DefaultUploadProvider(connection, accept, batchAppend) {
      this.connection = connection;
      this.accept = accept;
      this.batchAppend = batchAppend;
      this.uploader = null;
      this.batchId = null;
    }

    DefaultUploadProvider.prototype._ensureBatch = function() {
      if (!this.batchAppend || !this.uploader) {
        return this.connection.batchUpload().then((uploader) => {
          this.uploader = uploader;
        });
      } else {
        return Promise.resolve();
      }
    };

    DefaultUploadProvider.prototype._newBatch = function() {
      return this.connection.batchUpload().then((uploader) => {
        this.uploader = uploader;
      });
    };

    /**
     * Uploads an array of files. Should implicitly create a new or use an already existing batch.
     *
     * @param {Object[]} files the list of files to upload
     * @param {Function} callback a callback function that should be called when a file upload starts,
     * when progress is updated, when a file upload ends, and when an upload batch is complete
     **/
    DefaultUploadProvider.prototype.upload = function(files, callback) {
      this._ensureBatch().then(() => {
        if (files.length) {
          for (var i = 0; i < files.length; i++) {
            var file = files[i];
            var blob = new Mostly.Blob({ content: file });
            //this._uploadStarted(i, file);
            if (typeof callback === 'function') {
              callback({ type: 'uploadStarted', file: file });
            }
            this.uploader.upload(blob).then((result) => {
              callback({ type: 'uploadCompleted', fileIdx: result.blob.fileIdx });
            });
          }
          this.uploader.done().then((result) => {
            callback({ type: 'batchFinished', batchId: result.batch._batchId });
          });
        }
      });
    };

    /**
     * Cancels the current batch.
     **/
    DefaultUploadProvider.prototype.cancelBatch = function() {
      if (this.uploader) {
        if (this.uploader._batchId) {
          this.uploader.cancel();
        }
        this.uploader = null;
        this.batchId = null;
      }
    };

    /**
     * Executes an operation on the current batch.
     *
     * @param {String} operationId the operation to execute
     * @param {Object} params the operation params
     * @param {Object} headers the request headers
     **/
    DefaultUploadProvider.prototype.batchExecute = function(operationId, params, headers) {
      return this.connection.operation(operationId).then((operation) => {
        var options = {};
        if (headers) {
          options['headers'] = headers;
        }
        if (params.context) {
          operation = operation.context(params.context);
        }
        return operation
          .input(this.uploader)
          .params(params)
          .execute(options);
      });
    };

    /**
     * Returns whether the provider accepts a given file for upload or not.
     *
     * @param {Object} file the file to be checked
     * @return {Boolean} true if the current file is accepted by the current provider, false otherwise
     **/
    DefaultUploadProvider.prototype.accepts = function(file) {
      var mimeType = ((file.type !== '') ? file.type.match(/^[^\/]*\//)[0] : null);
      var fileType = file.name.match(/\.[^\.]*$/)[0];

      return !(this.accept && !(this.accept.indexOf(mimeType) > -1 || this.accept.indexOf(fileType) > -1));
    };

    /**
     * Returns whether or not the provider reports file upload progress.
     *
     * @return {Boolean} true if the provider reports progress, false otherwise
     **/
    DefaultUploadProvider.prototype.hasProgress = function() {
      return false;
    };

    /**
     * @polymerBehavior Mostly.UploaderBehavior
     */
    Mostly.UploaderBehavior = {

      properties: {
        /**
         * Accepted file extensions or mime types (comma separated values).
         */
        accept: String,

        /**
         * This flag determines whether the file should be immediately uploaded or not.
         */
        immediate: {
          type: Boolean,
          value: true
        },

        /**
         * Current batch id.
         */
        batchId: String,

        /**
         * List of files in the current batch.
         */
        files: {
          type: Array,
          value: []
        },

        /**
         * Flag that indicates if an upload is in progress.
         */
        uploading: {
          type: Boolean,
          value: false
        },

        /**
         * Allow multiple files to be added to the same batch.
         */
        batchAppend: {
          type: Boolean,
          value: false
        }
      },

      setupDropZone: function(el) {
        this._dropZone = el;
        this._dropZone.addEventListener('dragover', this._dragover.bind(this));
        this._dropZone.addEventListener('dragleave', this._dragleave.bind(this));
        this._dropZone.addEventListener('drop', this._drop.bind(this));
      },

      uploadFiles: function(files) {
        if (!this.accepts(files)) {
          console.warn('Can only upload ' + this.accept +' files.');
          return;
        }
        if (!this.connection) {
          throw 'Missing connection';
        }
        if (!this.batchAppend || !this.uploader) {
          this.files = [];
          this._newBatch().then(this._uploadeFiles.bind(this, files));
        } else {
          this._uploadeFiles(files);
        }

      },

      batchExecute: function(operationId, params, headers) {
        return this.connection.operation(operationId).then(function(operation) {
          var options = {};
          if (headers) {
            options['headers'] = headers;
          }
          if (params.context) {
            operation = operation.context(params.context);
          }
          return operation.input(this.uploader)
            .params(params)
            .execute(options)
            .then(function(data) {
              this.fire('response', {response: data});
              this.response = data;
              return this.response;
            }.bind(this))
            .catch(function(error) {
              this.fire('error', error);
              console.log('Batch Execute operation failed: ' + error);
              throw error;
            }.bind(this));
        }.bind(this));
      },

      cancelBatch: function() {
        if (this.uploader) {
          if (this.uploader._batchId) {
            this.uploader.cancel();
          }
          this.uploader = null;
          this.batchId = null;
        }
      },

      _uploadeFiles: function(files) {
        for (var i = 0; i < files.length; i++) {
          var file = files[i];
          file.progress = 0;
          file.error = false;
          file.complete = false;
          this.push('files', file);
          var blob = new Mostly.Blob({ content: file });
          this._uploadStarted(i, file);
          this.uploader.upload(blob)
            .then(function(result) {
              this._uploadFinished(result.blob.fileIdx);
            }.bind(this));
        }
        this.uploader.done().then(function(result) {
          this._batchFinished(result.batch._batchId);
        }.bind(this));
      },

      _newBatch: function() {
        return this.connection.batchUpload().then(function(uploader) {
          this.uploader = uploader;
        }.bind(this));
      },

      accepts: function(files) {
        if (files.length) {
          for (var i = 0; i < files.length; i++) {
            if (!this._accepts(files[i])) {
              return false;
            }
          }
          return true;
        } else {
          return this._accepts(files);
        }
      },

      _accepts: function(file) {
        var mimeType = ((file.type !== '') ? file.type.match(/^[^\/]*\//)[0] : null);
        var fileType = file.name.match(/\.[^\.]*$/)[0];
        if (this.accept && !(this.accept.indexOf(mimeType) > -1 || this.accept.indexOf(fileType) > -1)) {
          return false;
        } else {
          return true;
        }
      },

      _updateFile: function(index, values) {
        Object.keys(values).forEach(function (k) {
          this.set(['files', index, k].join('.'), values[k]);
        }.bind(this));
      },

      _batchFinished: function(batchId) {
        this.uploading = false;
        this.batchId = batchId;
        this.fire('batchFinished', {batchId: batchId});
      },

      _uploadStarted: function(fileIndex, file) {
        this.uploading = true;
      },

      _uploadFinished: function(index) {
        this._updateFile(index, {
          progress: 100,
          complete: true,
          index: index
        });
      },

      _uploadProgressUpdated: function(index, file, progress) {
        this._updateFile(index, {progress: progress}); // in percentage
      },

      _uploadSpeedUpdated: function(index, file, speed) {
        this._updateFile(index, {speed: speed}); // in KB/sec
      },

      // DnD
      _dragover: function(e) {
        e.preventDefault();
        this.toggleClass('hover', true, this._dropZone);
      },

      _dragleave: function() {
        this.toggleClass('hover', false, this._dropZone);
      },

      _drop: function(e) {
        this.toggleClass('hover', false, this._dropZone);
        e.preventDefault();
        this.uploadFiles(e.dataTransfer.files);
      }
    };
  })();
</script>
